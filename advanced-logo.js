// Advanced Interactive Logo System - Inspired by Soul.io
class InteractiveLogo3D {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        if (!this.container) return;
        
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        
        this.particles = [];
        this.logoFragments = [];
        this.isFragmented = false;
        this.mousePos = { x: 0, y: 0 };
        this.targetMousePos = { x: 0, y: 0 };
        this.fragmentationLevel = 0;
        
        this.init();
    }
    
    init() {
        this.setupRenderer();
        this.createLogo();
        this.setupLighting();
        this.setupEventListeners();
        this.animate();
    }
    
    setupRenderer() {
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.container.appendChild(this.renderer.domElement);
        
        this.camera.position.z = 8;
    }
    
    createLogo() {
        // Create main circular structure inspired by Incode logo
        this.createCircularSegments();
        this.createCenterLetter();
        this.createParticleField();
    }
    
    createCircularSegments() {
        // Outer ring segments
        const outerRingSegments = this.createRingSegments(2.5, 0.3, 12, 0x6366f1);
        
        // Middle ring segments  
        const middleRingSegments = this.createRingSegments(2.0, 0.25, 16, 0x8b5cf6);
        
        // Inner ring segments
        const innerRingSegments = this.createRingSegments(1.5, 0.2, 20, 0x00d4ff);
        
        // Add dotted outer elements
        this.createDottedElements();
        
        this.logoFragments = [...outerRingSegments, ...middleRingSegments, ...innerRingSegments];
    }
    
    createRingSegments(radius, thickness, segments, color) {
        const segmentFragments = [];\n        const angleStep = (Math.PI * 2) / segments;\n        \n        for (let i = 0; i < segments; i++) {\n            const startAngle = i * angleStep;\n            const endAngle = (i + 1) * angleStep;\n            \n            // Create gaps between segments (like in your logo)\n            const gapSize = angleStep * 0.15;\n            const adjustedEndAngle = endAngle - gapSize;\n            \n            const geometry = new THREE.RingGeometry(radius - thickness/2, radius + thickness/2, 8, 1, startAngle, adjustedEndAngle - startAngle);\n            \n            const material = new THREE.MeshPhongMaterial({ \n                color: color,\n                transparent: true,\n                opacity: 0.9,\n                shininess: 100\n            });\n            \n            const segment = new THREE.Mesh(geometry, material);\n            \n            // Store original position for reassembly\n            segment.userData = {\n                originalPosition: { x: 0, y: 0, z: 0 },\n                originalRotation: { x: 0, y: 0, z: 0 },\n                targetPosition: { x: 0, y: 0, z: 0 },\n                velocity: { x: 0, y: 0, z: 0 },\n                fragmentDirection: {\n                    x: Math.cos(startAngle + (adjustedEndAngle - startAngle) / 2) * 2,\n                    y: Math.sin(startAngle + (adjustedEndAngle - startAngle) / 2) * 2,\n                    z: (Math.random() - 0.5) * 1\n                },\n                rotationSpeed: {\n                    x: (Math.random() - 0.5) * 0.1,\n                    y: (Math.random() - 0.5) * 0.1,\n                    z: (Math.random() - 0.5) * 0.1\n                }\n            };\n            \n            this.scene.add(segment);\n            segmentFragments.push(segment);\n        }\n        \n        return segmentFragments;\n    }\n    \n    createDottedElements() {\n        // Create dotted segments inspired by your logo's outer elements\n        const dotRadius = 3.2;\n        const dots = 24;\n        \n        for (let i = 0; i < dots; i++) {\n            const angle = (i / dots) * Math.PI * 2;\n            const x = Math.cos(angle) * dotRadius;\n            const y = Math.sin(angle) * dotRadius;\n            \n            const geometry = new THREE.BoxGeometry(0.15, 0.08, 0.05);\n            const material = new THREE.MeshPhongMaterial({ \n                color: i % 3 === 0 ? 0x00d4ff : (i % 3 === 1 ? 0x8b5cf6 : 0x6366f1),\n                transparent: true,\n                opacity: 0.8\n            });\n            \n            const dot = new THREE.Mesh(geometry, material);\n            dot.position.set(x, y, 0);\n            dot.rotation.z = angle;\n            \n            // Store fragment data\n            dot.userData = {\n                originalPosition: { x, y, z: 0 },\n                originalRotation: { x: 0, y: 0, z: angle },\n                targetPosition: { x, y, z: 0 },\n                velocity: { x: 0, y: 0, z: 0 },\n                fragmentDirection: {\n                    x: Math.cos(angle) * 3,\n                    y: Math.sin(angle) * 3,\n                    z: (Math.random() - 0.5) * 2\n                },\n                rotationSpeed: {\n                    x: (Math.random() - 0.5) * 0.2,\n                    y: (Math.random() - 0.5) * 0.2,\n                    z: (Math.random() - 0.5) * 0.2\n                }\n            };\n            \n            this.scene.add(dot);\n            this.logoFragments.push(dot);\n        }\n    }\n    \n    createCenterLetter() {\n        // Create stylized \"IN\" in the center\n        const loader = new THREE.FontLoader();\n        \n        // Fallback: Create geometric representation of \"IN\"\n        this.createGeometricIN();\n    }\n    \n    createGeometricIN() {\n        // Create \"I\"\n        const iGeometry = new THREE.BoxGeometry(0.2, 1.2, 0.1);\n        const letterMaterial = new THREE.MeshPhongMaterial({ \n            color: 0x4a5568,\n            shininess: 100\n        });\n        \n        const letterI = new THREE.Mesh(iGeometry, letterMaterial);\n        letterI.position.set(-0.4, 0, 0.05);\n        \n        // Create \"N\"\n        const nGeometry1 = new THREE.BoxGeometry(0.15, 1.2, 0.1);\n        const nGeometry2 = new THREE.BoxGeometry(0.15, 1.2, 0.1);\n        const nGeometry3 = new THREE.BoxGeometry(0.8, 0.15, 0.1);\n        \n        const nPart1 = new THREE.Mesh(nGeometry1, letterMaterial);\n        const nPart2 = new THREE.Mesh(nGeometry2, letterMaterial);\n        const nPart3 = new THREE.Mesh(nGeometry3, letterMaterial);\n        \n        nPart1.position.set(0.1, 0, 0.05);\n        nPart2.position.set(0.7, 0, 0.05);\n        nPart3.position.set(0.4, 0, 0.05);\n        nPart3.rotation.z = Math.PI / 4;\n        \n        // Store center elements with fragment behavior\n        [letterI, nPart1, nPart2, nPart3].forEach(part => {\n            part.userData = {\n                originalPosition: { x: part.position.x, y: part.position.y, z: part.position.z },\n                originalRotation: { x: part.rotation.x, y: part.rotation.y, z: part.rotation.z },\n                targetPosition: { x: part.position.x, y: part.position.y, z: part.position.z },\n                velocity: { x: 0, y: 0, z: 0 },\n                fragmentDirection: {\n                    x: (Math.random() - 0.5) * 4,\n                    y: (Math.random() - 0.5) * 4,\n                    z: (Math.random() - 0.5) * 2\n                },\n                rotationSpeed: {\n                    x: (Math.random() - 0.5) * 0.15,\n                    y: (Math.random() - 0.5) * 0.15,\n                    z: (Math.random() - 0.5) * 0.15\n                }\n            };\n            \n            this.scene.add(part);\n            this.logoFragments.push(part);\n        });\n    }\n    \n    createParticleField() {\n        // Create ambient particle field for enhanced effects\n        const particleCount = 500;\n        const geometry = new THREE.BufferGeometry();\n        const positions = new Float32Array(particleCount * 3);\n        const colors = new Float32Array(particleCount * 3);\n        const sizes = new Float32Array(particleCount);\n        \n        const colorPalette = [\n            new THREE.Color(0x6366f1),\n            new THREE.Color(0x8b5cf6),\n            new THREE.Color(0x00d4ff),\n            new THREE.Color(0x4ade80)\n        ];\n        \n        for (let i = 0; i < particleCount; i++) {\n            const i3 = i * 3;\n            \n            positions[i3] = (Math.random() - 0.5) * 20;\n            positions[i3 + 1] = (Math.random() - 0.5) * 20;\n            positions[i3 + 2] = (Math.random() - 0.5) * 10;\n            \n            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];\n            colors[i3] = color.r;\n            colors[i3 + 1] = color.g;\n            colors[i3 + 2] = color.b;\n            \n            sizes[i] = Math.random() * 0.05 + 0.01;\n        }\n        \n        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));\n        \n        const material = new THREE.PointsMaterial({\n            size: 0.03,\n            vertexColors: true,\n            transparent: true,\n            opacity: 0.6,\n            blending: THREE.AdditiveBlending\n        });\n        \n        this.particles = new THREE.Points(geometry, material);\n        this.scene.add(this.particles);\n    }\n    \n    setupLighting() {\n        // Ambient light\n        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);\n        this.scene.add(ambientLight);\n        \n        // Main directional light\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n        directionalLight.position.set(5, 5, 5);\n        directionalLight.castShadow = true;\n        this.scene.add(directionalLight);\n        \n        // Colored accent lights\n        const accentLight1 = new THREE.PointLight(0x6366f1, 0.8, 100);\n        accentLight1.position.set(-5, 3, 3);\n        this.scene.add(accentLight1);\n        \n        const accentLight2 = new THREE.PointLight(0x8b5cf6, 0.8, 100);\n        accentLight2.position.set(5, -3, 3);\n        this.scene.add(accentLight2);\n    }\n    \n    setupEventListeners() {\n        this.container.addEventListener('mousemove', (e) => {\n            const rect = this.container.getBoundingClientRect();\n            this.targetMousePos.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;\n            this.targetMousePos.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;\n            \n            // Calculate distance from center to determine fragmentation\n            const distance = Math.sqrt(this.targetMousePos.x ** 2 + this.targetMousePos.y ** 2);\n            this.fragmentationLevel = Math.min(distance * 2, 1);\n        });\n        \n        this.container.addEventListener('mouseleave', () => {\n            this.fragmentationLevel = 0;\n        });\n        \n        window.addEventListener('resize', () => {\n            this.camera.aspect = this.container.clientWidth / this.container.clientHeight;\n            this.camera.updateProjectionMatrix();\n            this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);\n        });\n    }\n    \n    updateFragmentation() {\n        this.logoFragments.forEach((fragment, index) => {\n            const userData = fragment.userData;\n            \n            if (this.fragmentationLevel > 0.1) {\n                // Fragment the logo\n                const targetX = userData.originalPosition.x + userData.fragmentDirection.x * this.fragmentationLevel;\n                const targetY = userData.originalPosition.y + userData.fragmentDirection.y * this.fragmentationLevel;\n                const targetZ = userData.originalPosition.z + userData.fragmentDirection.z * this.fragmentationLevel;\n                \n                userData.targetPosition.x = targetX;\n                userData.targetPosition.y = targetY;\n                userData.targetPosition.z = targetZ;\n                \n                // Add rotation during fragmentation\n                fragment.rotation.x += userData.rotationSpeed.x * this.fragmentationLevel;\n                fragment.rotation.y += userData.rotationSpeed.y * this.fragmentationLevel;\n                fragment.rotation.z += userData.rotationSpeed.z * this.fragmentationLevel;\n                \n                // Reduce opacity during fragmentation\n                if (fragment.material) {\n                    fragment.material.opacity = 0.9 - (this.fragmentationLevel * 0.5);\n                }\n                \n            } else {\n                // Reassemble the logo\n                userData.targetPosition.x = userData.originalPosition.x;\n                userData.targetPosition.y = userData.originalPosition.y;\n                userData.targetPosition.z = userData.originalPosition.z;\n                \n                // Restore original rotation\n                const rotLerpSpeed = 0.1;\n                fragment.rotation.x += (userData.originalRotation.x - fragment.rotation.x) * rotLerpSpeed;\n                fragment.rotation.y += (userData.originalRotation.y - fragment.rotation.y) * rotLerpSpeed;\n                fragment.rotation.z += (userData.originalRotation.z - fragment.rotation.z) * rotLerpSpeed;\n                \n                // Restore opacity\n                if (fragment.material) {\n                    fragment.material.opacity += (0.9 - fragment.material.opacity) * 0.1;\n                }\n            }\n            \n            // Smooth movement with physics\n            const lerpSpeed = 0.08;\n            const dx = userData.targetPosition.x - fragment.position.x;\n            const dy = userData.targetPosition.y - fragment.position.y;\n            const dz = userData.targetPosition.z - fragment.position.z;\n            \n            userData.velocity.x += dx * 0.02;\n            userData.velocity.y += dy * 0.02;\n            userData.velocity.z += dz * 0.02;\n            \n            // Apply damping\n            userData.velocity.x *= 0.85;\n            userData.velocity.y *= 0.85;\n            userData.velocity.z *= 0.85;\n            \n            fragment.position.x += userData.velocity.x;\n            fragment.position.y += userData.velocity.y;\n            fragment.position.z += userData.velocity.z;\n        });\n    }\n    \n    animate() {\n        requestAnimationFrame(() => this.animate());\n        \n        // Smooth mouse movement\n        this.mousePos.x += (this.targetMousePos.x - this.mousePos.x) * 0.1;\n        this.mousePos.y += (this.targetMousePos.y - this.mousePos.y) * 0.1;\n        \n        // Update fragmentation\n        this.updateFragmentation();\n        \n        // Animate particles\n        if (this.particles) {\n            this.particles.rotation.y += 0.001;\n            \n            // Mouse influence on particles\n            const positions = this.particles.geometry.attributes.position.array;\n            for (let i = 0; i < positions.length; i += 3) {\n                const x = positions[i];\n                const y = positions[i + 1];\n                \n                const mouseInfluence = 1 - Math.min(Math.sqrt((this.mousePos.x * 10 - x) ** 2 + (this.mousePos.y * 10 - y) ** 2) / 5, 1);\n                positions[i + 2] += Math.sin(Date.now() * 0.001 + i) * 0.01 * mouseInfluence;\n            }\n            this.particles.geometry.attributes.position.needsUpdate = true;\n        }\n        \n        // Camera subtle movement based on mouse\n        this.camera.position.x += (this.mousePos.x * 0.5 - this.camera.position.x) * 0.05;\n        this.camera.position.y += (this.mousePos.y * 0.5 - this.camera.position.y) * 0.05;\n        \n        this.renderer.render(this.scene, this.camera);\n    }\n}\n\n// Export for use in main script\nwindow.InteractiveLogo3D = InteractiveLogo3D;